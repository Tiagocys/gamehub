<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gimerr - Admin</title>
  <style id="admin-guard-style">html{visibility:hidden;}</style>
  <script>
    (() => {
      try {
        const hasSession = localStorage.getItem("gimerr-auth-token") || localStorage.getItem("gimerr-auth-session");
        if (!hasSession) {
          window.location.replace("index.html");
        }
      } catch (_err) {
        window.location.replace("index.html");
      }
    })();
  </script>
  <style>
    :root {
      --bg: #f4f6fb;
      --card: #ffffff;
      --muted: #5f6f8c;
      --text: #0f2557;
      --accent: #1b4fd3;
      --accent-2: #4e7dff;
      --danger: #e2526d;
      --border: rgba(15,37,87,0.08);
      --radius: 14px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      min-height: 100vh;
    }
    header {
      padding: 18px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(255,255,255,0.92);
    }
    .logo { display: flex; align-items: center; gap: 10px; }
    .logo img { width: 110px; height: auto; }
    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(27,79,211,0.1);
      color: var(--accent-2);
      font-size: 12px;
      border: 1px solid var(--border);
    }
    .header-actions { display: flex; gap: 14px; align-items: center; }
    main { max-width: 760px; margin: 0 auto; padding: 28px 20px 60px; display: grid; gap: 20px; }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: 0 12px 30px rgba(15,37,87,0.08);
    }
    h1 { margin: 0 0 12px; font-size: 28px; color: #0d1b3b; }
    p { color: var(--muted); margin: 6px 0 12px; }
    label { display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px; }
    input, textarea {
      width: 100%;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(15,37,87,0.02);
      color: var(--text);
      font-size: 14px;
      outline: none;
      transition: border 0.2s, box-shadow 0.2s;
    }
    input:focus, textarea:focus {
      border-color: rgba(27,79,211,0.35);
      box-shadow: 0 0 0 3px rgba(27,79,211,0.12);
    }
    textarea { resize: vertical; min-height: 90px; }
    button, .btn-link {
      padding: 12px 20px;
      border: none;
      border-radius: 999px;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.2s;
      color: #f8fbff;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      box-shadow: 0 12px 24px rgba(27,79,211,0.25);
      width: 100%;
      margin-top: 12px;
    }
    button.secondary, .btn-link.secondary {
      background: transparent;
      color: var(--text);
      box-shadow: none;
      border: 1px solid var(--border);
    }
    button:active, .btn-link:active { transform: translateY(1px); }
    .btn-link {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
    }
    .status { display: flex; align-items: center; gap: 8px; font-size: 14px; }
    .dot { width: 10px; height: 10px; border-radius: 999px; background: #f6d87c; }
    .dot.ok { background: var(--accent); }
    .muted { color: var(--muted); font-size: 13px; }
    .notice { padding: 10px 12px; border-radius: 10px; background: rgba(118,168,255,0.08); border: 1px solid var(--border); font-size: 13px; }
    .error { color: var(--danger); font-size: 13px; min-height: 18px; }
    .success { color: var(--accent); font-size: 13px; min-height: 18px; }
    .divider { height: 1px; background: var(--border); margin: 16px 0; }
    form .row { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); gap: 10px; }
    .list { display: grid; gap: 12px; }
    .chip-btn {
      background: transparent;
      color: var(--accent);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 12px;
      font-weight: 600;
      cursor: pointer;
      width: auto;
      margin-top: 0;
      box-shadow: none;
    }
    #logo-preview-wrapper {
      display: none;
      margin-top: 10px;
      background: rgba(15,37,87,0.02);
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 10px;
    }
    #logo-preview-wrapper img {
      width: 100%;
      max-height: 200px;
      object-fit: contain;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <div id="page-loader" class="page-loader">
    <img src="img/logo.png" alt="Carregando" />
  </div>
  <header>
    <div class="logo">
      <a href="index.html"><img src="img/logo.png" alt="Gimerr" /></a>
      <span class="pill">Admin</span>
    </div>
    <div class="header-actions">
      <div class="status">
        <div class="dot" id="status-dot"></div>
        <span id="status-text">Desconectado</span>
      </div>
      <button id="header-auth-btn" class="secondary">Entrar</button>
    </div>
  </header>

  <main>
    <section class="card">
      <h1>Criar novo servidor</h1>
      <p>Somente administradores podem criar servidores. Nome, site oficial e logo são obrigatórios.</p>
      <div class="notice" id="session-status">Faça login em login.html para continuar.</div>
      <div class="notice" id="edit-request-banner" style="display:none; gap:10px; align-items:center; justify-content:space-between;">
        <div>
          Editando solicitação de usuário:
          <strong id="edit-request-title"></strong>
        </div>
        <button type="button" class="chip-btn" id="clear-edit-btn">Limpar</button>
      </div>
      <div class="divider"></div>

      <form id="server-form">
        <label for="server-name">Nome do servidor *</label>
        <input id="server-name" placeholder="Ex: Tibia OT Ultra" required />

        <label for="server-site">Site oficial *</label>
        <input id="server-site" placeholder="https://seuservidor.com" required />

        <label for="server-discord">Convite do Discord oficial *</label>
        <input id="server-discord" placeholder="https://discord.gg/seu-servidor" required />

        <label for="server-logo">Logo do servidor (png/jpg/webp) *</label>
        <input id="server-logo" type="file" accept="image/png,image/jpeg,image/webp" required />
        <div id="logo-preview-wrapper">
          <label>Pré-visualização</label>
          <img id="server-logo-preview" alt="Pré-visualização da logo" />
        </div>

        <button type="submit">Salvar servidor</button>
        <div class="error" id="form-error"></div>
        <div class="success" id="form-success"></div>
      </form>
    </section>

    <section class="card">
      <h1>Solicitações de games</h1>
      <p>Revise e aprove/reprove os envios de usuários. Cada decisão atualiza o status e dispara e-mail. Ao aprovar uma solicitação, pendências do mesmo domínio são recusadas automaticamente.</p>
      <div class="notice" id="requests-status">Carregando...</div>
      <div id="requests-nav" style="display:none;align-items:center;justify-content:space-between;gap:8px;margin-top:8px;">
        <button id="requests-prev" class="chip-btn" type="button">Anterior</button>
        <span id="requests-counter" class="muted">1 de 1</span>
        <button id="requests-next" class="chip-btn" type="button">Próxima</button>
      </div>
      <div id="requests-empty" class="muted" style="display:none;">Nenhuma solicitação pendente.</div>
      <div id="requests-list" class="list"></div>
    </section>

    <section class="card">
      <h1>Denúncias pendentes</h1>
      <p>Revise denúncias de anúncios e perfis para aplicar medidas de moderação.</p>
      <div class="notice" id="reports-status">Carregando...</div>
      <div id="reports-nav" style="display:none;align-items:center;justify-content:space-between;gap:8px;margin-top:8px;">
        <button id="reports-prev" class="chip-btn" type="button">Anterior</button>
        <span id="reports-counter" class="muted">1 de 1</span>
        <button id="reports-next" class="chip-btn" type="button">Próxima</button>
      </div>
      <div id="reports-empty" class="muted" style="display:none;">Nenhuma denúncia pendente.</div>
      <div id="reports-list" class="list"></div>
    </section>
  </main>

  <script src="env.js"></script>
  <script type="module">
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2.40.0";

    const pageLoader = document.getElementById("page-loader");
    let loaderDone = false;
    let windowLoaded = false;
    let avatarReady = false;

    function hideLoader() {
      if (loaderDone || !pageLoader) return;
      if (!windowLoaded || !avatarReady) return;
      loaderDone = true;
      pageLoader.classList.add("hidden");
      pageLoader.remove();
    }

    function markAvatarReady() {
      avatarReady = true;
      hideLoader();
    }

    window.addEventListener("load", () => {
      windowLoaded = true;
      hideLoader();
    });

    const env = window.__ENV || {};
    const SUPABASE_URL = env.SUPABASE_URL || "YOUR_SUPABASE_URL";
    const SUPABASE_ANON_KEY = env.SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

    const statusDot = document.getElementById("status-dot");
    const statusText = document.getElementById("status-text");
    const sessionStatus = document.getElementById("session-status");
    const headerAuthBtn = document.getElementById("header-auth-btn");
    const serverForm = document.getElementById("server-form");
    const formError = document.getElementById("form-error");
    const formSuccess = document.getElementById("form-success");
    const serverNameInput = document.getElementById("server-name");
    const serverSiteInput = document.getElementById("server-site");
    const serverDiscordInput = document.getElementById("server-discord");
    const serverLogoInput = document.getElementById("server-logo");
    const logoPreviewWrapper = document.getElementById("logo-preview-wrapper");
    const logoPreview = document.getElementById("server-logo-preview");
    const editBanner = document.getElementById("edit-request-banner");
    const editBannerTitle = document.getElementById("edit-request-title");
    const clearEditBtn = document.getElementById("clear-edit-btn");
    const MAX_LOGO_BYTES = 3 * 1024 * 1024; // 3MB
    const requestsList = document.getElementById("requests-list");
    const requestsEmpty = document.getElementById("requests-empty");
    const requestsStatus = document.getElementById("requests-status");
    const requestsNav = document.getElementById("requests-nav");
    const requestsPrevBtn = document.getElementById("requests-prev");
    const requestsNextBtn = document.getElementById("requests-next");
    const requestsCounter = document.getElementById("requests-counter");
    const reportsList = document.getElementById("reports-list");
    const reportsEmpty = document.getElementById("reports-empty");
    const reportsStatus = document.getElementById("reports-status");
    const reportsNav = document.getElementById("reports-nav");
    const reportsPrevBtn = document.getElementById("reports-prev");
    const reportsNextBtn = document.getElementById("reports-next");
    const reportsCounter = document.getElementById("reports-counter");

    const SESSION_STORAGE_KEY = "gimerr-auth-session";
    let supabase;
    let authListenerAttached = false;
    let profile = null;
    let requestCache = [];
    let reportCache = [];
    let requestCursor = 0;
    let reportCursor = 0;
    let editingRequest = null;

    function getProjectRef() {
      try {
        return new URL(SUPABASE_URL).hostname.split(".")[0];
      } catch (_err) {
        return null;
      }
    }

    function decodeJwtPart(token, index) {
      if (!token) return null;
      const parts = token.split(".");
      if (parts.length <= index) return null;
      const base64 = parts[index].replace(/-/g, "+").replace(/_/g, "/");
      const padded = base64 + "===".slice((base64.length + 3) % 4);
      try {
        return JSON.parse(atob(padded));
      } catch (_err) {
        return null;
      }
    }

    function decodeJwtPayload(token) {
      return decodeJwtPart(token, 1);
    }

    function isTokenForProject(token) {
      const payload = decodeJwtPayload(token);
      const projectRef = getProjectRef();
      if (!payload?.iss || !projectRef) return false;
      return String(payload.iss).includes(projectRef);
    }

    function checkAnonKey() {
      const payload = decodeJwtPayload(SUPABASE_ANON_KEY);
      const projectRef = getProjectRef();
      if (!payload || !projectRef) return;
      if (payload.ref !== projectRef || payload.role !== "anon") {
        console.warn("SUPABASE_ANON_KEY parece inválida para este projeto.", payload);
        requestsStatus.textContent = "Chave anon incorreta em public/env.js.";
      }
    }

    function revealAdminPage() {
      document.documentElement.style.visibility = "visible";
      const guard = document.getElementById("admin-guard-style");
      if (guard) guard.remove();
    }

    function setStatus(ok, text) {
      statusDot.classList.toggle("ok", ok);
      statusText.textContent = text;
    }

    function ensureHttpsPrefix(raw) {
      const trimmed = (raw || "").trim();
      if (!trimmed) return "";
      const withoutProtocol = trimmed.replace(/^https?:\/\//i, "");
      return `https://${withoutProtocol}`;
    }

    function normalizeOptionalUrl(raw) {
      const trimmed = (raw || "").trim();
      if (!trimmed) return null;
      try {
        const withProtocol = ensureHttpsPrefix(trimmed);
        const url = new URL(withProtocol);
        if (url.hostname.toLowerCase() !== "discord.gg") return null;
        if (!url.pathname || url.pathname === "/") return null;
        url.protocol = "https:";
        url.hash = "";
        return `${url.origin}${url.pathname.replace(/\/+$/, "")}`;
      } catch (_err) {
        return null;
      }
    }

    function formatDiscordInviteHtml(urlString) {
      const normalized = normalizeOptionalUrl(urlString || "");
      if (!normalized) return '<span class="muted">Discord: não informado</span>';
      const safeUrl = encodeURI(normalized);
      return `Discord: <a href="${safeUrl}" target="_blank" rel="noopener" class="pill pill-link">Abrir convite</a>`;
    }

    function isMissingDiscordInviteColumnError(error) {
      if (!error) return false;
      return error.code === "42703" || String(error.message || "").includes("discord_invite");
    }

    function isMissingReportsTableError(error) {
      if (!error) return false;
      return error.code === "42P01" || String(error.message || "").toLowerCase().includes("reports");
    }

    function formatDateTime(value) {
      if (!value) return "-";
      try {
        return new Date(value).toLocaleString("pt-BR");
      } catch (_err) {
        return String(value);
      }
    }

    function getUserDisplayName(user) {
      if (!user) return "Usuário";
      const first = String(user.first_name || "").trim();
      const last = String(user.last_name || "").trim();
      const full = `${first} ${last}`.trim();
      return full || user.email || user.id || "Usuário";
    }

    function persistLocalSession(session) {
      if (session) {
        localStorage.setItem(
          SESSION_STORAGE_KEY,
          JSON.stringify({
            access_token: session.access_token,
            refresh_token: session.refresh_token,
          }),
        );
      } else {
        localStorage.removeItem(SESSION_STORAGE_KEY);
      }
    }

    async function restoreSessionFromStorage() {
      const raw = localStorage.getItem(SESSION_STORAGE_KEY);
      if (!raw) return null;
      try {
        const saved = JSON.parse(raw);
        if (!saved.access_token || !saved.refresh_token) return null;
        const { data, error } = await supabase.auth.setSession({
          access_token: saved.access_token,
          refresh_token: saved.refresh_token,
        });
        if (error) {
          console.error(error);
          localStorage.removeItem(SESSION_STORAGE_KEY);
          return null;
        }
        return data.session;
      } catch (err) {
        console.error(err);
        localStorage.removeItem(SESSION_STORAGE_KEY);
        return null;
      }
    }

    function configureHeaderButton(userPresent) {
      if (!headerAuthBtn) return;
      headerAuthBtn.disabled = false;
      if (userPresent) {
        headerAuthBtn.textContent = "Sair";
        headerAuthBtn.onclick = async () => {
          try {
            ensureClient();
            headerAuthBtn.disabled = true;
            await supabase.auth.signOut();
            setStatus(false, "Sessão encerrada");
            await refreshSession();
          } catch (err) {
            console.error(err);
            headerAuthBtn.disabled = false;
          }
        };
      } else {
        headerAuthBtn.textContent = "Entrar";
        headerAuthBtn.onclick = () => window.location.href = "login.html";
      }
    }

    function ensureClient() {
      if (!SUPABASE_URL || SUPABASE_URL.startsWith("YOUR_") || !SUPABASE_ANON_KEY || SUPABASE_ANON_KEY.startsWith("YOUR_")) {
        setStatus(false, "Defina SUPABASE_URL e SUPABASE_ANON_KEY em public/env.js");
        throw new Error("Supabase URL/key não configurados");
      }
      checkAnonKey();
      supabase = supabase || createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
        auth: {
          persistSession: true,
          autoRefreshToken: true,
          detectSessionInUrl: true,
          storageKey: "gimerr-auth-token",
        },
      });
      if (!authListenerAttached) {
        supabase.auth.onAuthStateChange((_event, session) => {
          persistLocalSession(session);
          refreshSession();
        });
        authListenerAttached = true;
      }
      return supabase;
    }

    function setLogoPreview(src) {
      if (!logoPreviewWrapper || !logoPreview) return;
      if (src) {
        logoPreview.src = src;
        logoPreviewWrapper.style.display = "block";
      } else {
        logoPreviewWrapper.style.display = "none";
        logoPreview.removeAttribute("src");
      }
    }

    function enterEditMode(req) {
      editingRequest = req || null;
      formError.textContent = "";
      formSuccess.textContent = "";
      if (!req) {
        if (serverLogoInput) {
          serverLogoInput.required = true;
          serverLogoInput.setAttribute("required", "true");
        }
        setLogoPreview("");
        if (editBanner) editBanner.style.display = "none";
        return;
      }
      if (serverNameInput) serverNameInput.value = req.name || "";
      if (serverSiteInput) serverSiteInput.value = req.website || "";
      if (serverDiscordInput) serverDiscordInput.value = req.discord_invite || "";
      if (serverLogoInput) {
        serverLogoInput.value = "";
        serverLogoInput.required = false;
        serverLogoInput.removeAttribute("required");
      }
      const previewSrc = req.displayCoverUrl || req.cover_url || "";
      setLogoPreview(previewSrc);
      if (editBanner) {
        editBanner.style.display = "flex";
        editBanner.style.flexWrap = "wrap";
        if (editBannerTitle) {
          editBannerTitle.textContent = `${req.name || "Solicitação"} (${req.website || "-"})`;
        }
      }
      serverForm?.scrollIntoView({ behavior: "smooth", block: "start" });
      formError.textContent = "Revise os dados antes de salvar.";
    }

    function handleLogoChange() {
      const file = serverLogoInput?.files?.[0];
      if (!file) {
        if (editingRequest?.cover_url) {
          setLogoPreview(editingRequest.displayCoverUrl || editingRequest.cover_url);
        } else {
          setLogoPreview("");
        }
        return;
      }
      const reader = new FileReader();
      reader.onload = (event) => {
        setLogoPreview(event.target?.result || "");
      };
      reader.readAsDataURL(file);
    }

    function extractStoragePath(urlString) {
      if (!urlString) return null;
      try {
        const parsed = new URL(urlString);
        const marker = "/server_logos/";
        const idx = parsed.pathname.indexOf(marker);
        if (idx === -1) return null;
        return parsed.pathname.substring(idx + marker.length);
      } catch (_err) {
        return null;
      }
    }

    async function enhanceRequestsWithSignedUrls(list) {
      if (!list || list.length === 0) return [];
      return Promise.all(list.map(async (req) => {
        const path = extractStoragePath(req.cover_url);
        if (!path) return { ...req, displayCoverUrl: req.cover_url };
        try {
          ensureClient();
          const { data, error } = await supabase.storage
            .from("server_logos")
            .createSignedUrl(path, 60 * 60);
          if (error) throw error;
          return { ...req, displayCoverUrl: data?.signedUrl || req.cover_url };
        } catch (err) {
          console.warn("Erro ao gerar URL assinada", err);
          return { ...req, displayCoverUrl: req.cover_url };
        }
      }));
    }

    async function upsertProfile(user) {
      const payload = {
        id: user.id,
        username: user.user_metadata?.full_name?.split(" ")?.[0] || user.email.split("@")[0],
        email: user.email,
        avatar_url: user.user_metadata?.avatar_url ?? null
      };
      const { error } = await supabase.from("users").upsert(payload, { onConflict: "id" });
      if (error) throw error;
    }

    async function fetchProfile(userId) {
      const { data, error } = await supabase.from("users").select("id, username, is_admin").eq("id", userId).single();
      if (error && error.code !== "PGRST116") throw error;
      return data;
    }

    async function refreshSession() {
      try {
        ensureClient();
        const { data } = await supabase.auth.getSession();
        let session = data.session;
        if (!session) {
          session = await restoreSessionFromStorage();
        }
        if (session?.user) {
          if (!isTokenForProject(session.access_token)) {
            console.warn("Sessão não corresponde ao projeto atual. Limpando login.");
            localStorage.removeItem("gimerr-auth-token");
            localStorage.removeItem("gimerr-auth-session");
            await supabase.auth.signOut();
            window.location.href = "index.html";
            return;
          }
          const user = session.user;
          await upsertProfile(user);
          profile = await fetchProfile(user.id);
          setStatus(true, "Sessão ativa");
          sessionStatus.textContent = profile?.is_admin
            ? `Logado como ${profile.username} (admin)`
            : `Logado como ${profile?.username || user.email} (sem permissão de admin)`;
          if (profile?.is_admin) {
            revealAdminPage();
            await Promise.all([fetchRequests(), fetchReports()]);
          } else {
            requestsStatus.textContent = "Restrito aos admins.";
            reportsStatus.textContent = "Restrito aos admins.";
            window.location.href = "index.html";
          }
        } else {
          profile = null;
          setStatus(false, "Sem sessão");
          sessionStatus.textContent = "Faça login em login.html para continuar.";
          requestsList.innerHTML = "";
          if (requestsNav) requestsNav.style.display = "none";
          requestsEmpty.style.display = "block";
          requestsEmpty.textContent = "Faça login para ver solicitações.";
          reportsList.innerHTML = "";
          if (reportsNav) reportsNav.style.display = "none";
          reportsEmpty.style.display = "block";
          reportsEmpty.textContent = "Faça login para ver denúncias.";
          window.location.href = "index.html";
          return;
        }
        configureHeaderButton(session?.user || null);
      } catch (err) {
        console.error(err);
        setStatus(false, "Erro");
        sessionStatus.textContent = err?.message || "Erro ao checar sessão.";
        requestsStatus.textContent = "Erro ao checar sessão.";
        reportsStatus.textContent = "Erro ao checar sessão.";
        revealAdminPage();
      } finally {
        markAvatarReady();
      }
    }

    async function uploadLogo(file, userId) {
      const ext = file.name.split(".").pop();
      const path = `${userId}/server-logo-${crypto.randomUUID()}.${ext}`;
      const bucket = supabase.storage.from("server_logos");
      const { error, data } = await bucket.upload(path, file, {
        cacheControl: "3600",
        upsert: false,
        contentType: file.type
      });
      if (error) throw error;
      const { data: publicData, error: publicErr } = bucket.getPublicUrl(path);
      if (publicErr) throw publicErr;
      return { path: data.path, publicUrl: publicData.publicUrl };
    }

    serverForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      formError.textContent = "";
      formSuccess.textContent = "";
      requestsStatus.textContent = "";

      try {
        ensureClient();
        const { data: sessionData } = await supabase.auth.getSession();
        const user = sessionData.session?.user;
        const accessToken = sessionData.session?.access_token || "";
        if (!user) {
          formError.textContent = "Faça login com Google.";
          return;
        }
        if (!profile?.is_admin) {
          formError.textContent = "Apenas administradores podem criar servidores.";
          return;
        }

        const name = serverNameInput?.value.trim();
        const site = serverSiteInput?.value.trim();
        const discordInviteRaw = serverDiscordInput?.value.trim() || "";
        const file = serverLogoInput?.files?.[0];

        if (!name || !site) {
          formError.textContent = "Preencha nome e site do game.";
          return;
        }

        const discordInvite = normalizeOptionalUrl(discordInviteRaw);
        if (!discordInvite) {
          formError.textContent = "Use um convite que comece com https://discord.gg/";
          return;
        }

        if (file && file.size > MAX_LOGO_BYTES) {
          formError.textContent = "Logo deve ter no máximo 3MB.";
          return;
        }

        const logoSummary = file
          ? `${file.name} (${(file.size / (1024 * 1024)).toFixed(2)} MB)`
          : editingRequest
            ? "Logo enviada pelo usuário (mantida)"
            : "Nenhuma logo selecionada";

        const summary = [
          `Servidor: ${name}`,
          `Site: ${site}`,
          `Discord: ${discordInvite}`,
          `Logo: ${logoSummary}`,
          `Status: ativo`
        ].join("\n");
        const confirmCreate = window.confirm(`${summary}\n\nDeseja continuar?`);
        if (!confirmCreate) {
          formError.textContent = "Envio cancelado pelo usuário.";
          return;
        }

        requestsStatus.textContent = "Salvando servidor...";
        let bannerUrl = editingRequest?.cover_url || editingRequest?.displayCoverUrl || null;
        if (file) {
          const { publicUrl } = await uploadLogo(file, user.id);
          bannerUrl = publicUrl;
        }
        if (!bannerUrl) {
          formError.textContent = "Adicione ou mantenha uma logo para continuar.";
          return;
        }

        if (editingRequest?.id) {
          const { data: approveData, error: approveErr } = await supabase.functions.invoke("game_approve", {
            body: {
              requestId: editingRequest.id,
              approved: true,
              note: "Aprovado com ajustes pelo admin.",
              override: {
                name,
                website: site,
                discord_invite: discordInvite,
                cover_url: bannerUrl
              }
            },
            headers: accessToken
              ? {
                  Authorization: `Bearer ${accessToken}`,
                  apikey: SUPABASE_ANON_KEY
                }
              : {}
          });
          if (approveErr || !approveData?.ok) {
            throw new Error(approveErr?.message || approveData?.error || "Erro ao atualizar status da solicitação.");
          }
          await fetchRequests();
        } else {
          let { error: insertErr } = await supabase.from("servers").insert({
            name,
            game_type: "general",
            official_site: site,
            discord_invite: discordInvite,
            banner_url: bannerUrl,
            status: "active"
          });
          if (isMissingDiscordInviteColumnError(insertErr)) {
            const fallback = await supabase.from("servers").insert({
              name,
              game_type: "general",
              official_site: site,
              banner_url: bannerUrl,
              status: "active"
            });
            insertErr = fallback.error;
          }
          if (insertErr) throw insertErr;
        }

        const editedName = editingRequest?.name;
        formSuccess.textContent = editedName
          ? "Solicitação aprovada com os ajustes e servidor salvo."
          : "Servidor criado com sucesso!";
        serverForm.reset();
        setLogoPreview("");
        enterEditMode(null);
        if (editedName) {
          requestsStatus.textContent = `Solicitação de "${editedName}" aprovada com ajustes.`;
        }
        requestsStatus.textContent ||= "Servidor salvo.";
      } catch (err) {
        console.error(err);
        formError.textContent = err?.message || "Erro ao criar servidor.";
        if (!formError.textContent && typeof err === "object") {
          formError.textContent = JSON.stringify(err);
        }
        requestsStatus.textContent = "Erro ao salvar servidor.";
      }
    });

    async function fetchRequests() {
      try {
        requestsStatus.textContent = "Carregando...";
        let { data, error } = await supabase
          .from("game_requests")
          .select("id,name,website,discord_invite,cover_url,user_email,status,created_at")
          .eq("status", "pending")
          .order("created_at", { ascending: true });
        if (isMissingDiscordInviteColumnError(error)) {
          const fallback = await supabase
            .from("game_requests")
            .select("id,name,website,cover_url,user_email,status,created_at")
            .eq("status", "pending")
            .order("created_at", { ascending: true });
          data = (fallback.data || []).map((item) => ({ ...item, discord_invite: null }));
          error = fallback.error;
        }
        if (error) throw error;
        requestCache = await enhanceRequestsWithSignedUrls(data || []);
        renderRequests(requestCache);
        requestsStatus.textContent = "Pronto";
      } catch (err) {
        console.error(err);
        if (requestsNav) requestsNav.style.display = "none";
        requestsStatus.textContent = err?.message || "Erro ao carregar solicitações.";
        requestsEmpty.style.display = "block";
        requestsEmpty.textContent = "Erro ao carregar solicitações.";
      }
    }

    function renderRequests(list) {
      requestsList.innerHTML = "";
      if (!list || list.length === 0) {
        requestCursor = 0;
        if (requestsNav) requestsNav.style.display = "none";
        requestsEmpty.style.display = "block";
        return;
      }
      if (requestsNav) requestsNav.style.display = "flex";
      requestsEmpty.style.display = "none";
      requestCursor = Math.min(Math.max(requestCursor, 0), list.length - 1);
      if (requestsCounter) {
        requestsCounter.textContent = `${requestCursor + 1} de ${list.length}`;
      }
      if (requestsPrevBtn) requestsPrevBtn.disabled = requestCursor <= 0;
      if (requestsNextBtn) requestsNextBtn.disabled = requestCursor >= list.length - 1;

      const req = list[requestCursor];
      const card = document.createElement("div");
      card.className = "notice";
      card.style.display = "grid";
      card.style.gap = "8px";
      card.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
          <div>
            <strong>${req.name}</strong>
            <div class="muted">${req.website}</div>
          </div>
          <span class="pill">${req.status}</span>
        </div>
        ${req.displayCoverUrl || req.cover_url ? `<img src="${req.displayCoverUrl || req.cover_url}" alt="${req.name}" style="width:100%;max-height:180px;object-fit:cover;border-radius:12px;border:1px solid var(--border);" />` : ""}
        <div class="muted">Usuário: ${req.user_email || "-"}</div>
        <div class="muted">${formatDiscordInviteHtml(req.discord_invite)}</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button class="btn secondary" data-action="prefill" data-id="${req.id}" style="flex:1;">Editar antes de aprovar</button>
          <button class="btn secondary" data-action="approve" data-id="${req.id}" style="flex:1;">Aprovar</button>
          <button class="btn secondary" data-action="reject" data-id="${req.id}" style="flex:1;">Recusar</button>
        </div>
      `;
      requestsList.appendChild(card);
    }

    function escapeHtml(value) {
      return String(value || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    async function fetchReports() {
      try {
        reportsStatus.textContent = "Carregando...";
        let { data, error } = await supabase
          .from("reports")
          .select("id,target_type,listing_id,reported_user_id,reporter_id,reason,evidence_images,status,created_at")
          .eq("status", "pending")
          .order("created_at", { ascending: true });
        if (error && error.code === "42703" && String(error.message || "").includes("evidence_images")) {
          const fallback = await supabase
            .from("reports")
            .select("id,target_type,listing_id,reported_user_id,reporter_id,reason,status,created_at")
            .eq("status", "pending")
            .order("created_at", { ascending: true });
          data = (fallback.data || []).map((item) => ({ ...item, evidence_images: [] }));
          error = fallback.error;
        }
        if (isMissingReportsTableError(error)) {
          reportsList.innerHTML = "";
          if (reportsNav) reportsNav.style.display = "none";
          reportsEmpty.style.display = "block";
          reportsEmpty.textContent = "Tabela de denúncias não encontrada. Aplique as migrations mais recentes.";
          reportsStatus.textContent = "Migration pendente";
          return;
        }
        if (error) throw error;

        const rows = data || [];
        if (rows.length === 0) {
          reportCache = [];
          renderReports(reportCache);
          reportsStatus.textContent = "Pronto";
          return;
        }

        const listingIds = Array.from(new Set(rows.map((row) => row.listing_id).filter(Boolean)));
        const userIds = new Set(rows.flatMap((row) => [row.reporter_id, row.reported_user_id]).filter(Boolean));

        const listingsMap = new Map();
        const listingServerIds = new Set();
        if (listingIds.length > 0) {
          const { data: listingRows, error: listingError } = await supabase
            .from("listings")
            .select("id,title,user_id,server_id")
            .in("id", listingIds);
          if (listingError) throw listingError;
          (listingRows || []).forEach((item) => {
            listingsMap.set(item.id, item);
            if (item?.user_id) userIds.add(item.user_id);
            if (item?.server_id) listingServerIds.add(item.server_id);
          });
        }

        const serversMap = new Map();
        const serverIds = Array.from(listingServerIds);
        if (serverIds.length > 0) {
          const { data: serverRows, error: serverError } = await supabase
            .from("servers")
            .select("id,name")
            .in("id", serverIds);
          if (!serverError) {
            (serverRows || []).forEach((server) => {
              serversMap.set(server.id, server);
            });
          }
        }

        const usersMap = new Map();
        const allUserIds = Array.from(userIds);
        if (allUserIds.length > 0) {
          const { data: userRows, error: userError } = await supabase
            .from("users")
            .select("id,first_name,last_name,email,status")
            .in("id", allUserIds);
          if (userError) throw userError;
          (userRows || []).forEach((user) => usersMap.set(user.id, user));
        }

        reportCache = rows.map((row) => {
          const listing = row.listing_id ? listingsMap.get(row.listing_id) : null;
          const listingServer = listing?.server_id ? serversMap.get(listing.server_id) : null;
          const resolvedUserId = row.reported_user_id || listing?.user_id || null;
          const reporter = usersMap.get(row.reporter_id) || null;
          const reportedUser = resolvedUserId ? (usersMap.get(resolvedUserId) || null) : null;
          return {
            ...row,
            listing,
            listing_server_name: listingServer?.name || null,
            resolved_user_id: resolvedUserId,
            reporter,
            reported_user: reportedUser,
          };
        });
        renderReports(reportCache);
        reportsStatus.textContent = "Pronto";
      } catch (err) {
        console.error(err);
        if (reportsNav) reportsNav.style.display = "none";
        reportsStatus.textContent = err?.message || "Erro ao carregar denúncias.";
        reportsEmpty.style.display = "block";
        reportsEmpty.textContent = "Erro ao carregar denúncias.";
      }
    }

    function renderReports(list) {
      reportsList.innerHTML = "";
      if (!list || list.length === 0) {
        reportCursor = 0;
        if (reportsNav) reportsNav.style.display = "none";
        reportsEmpty.style.display = "block";
        return;
      }
      if (reportsNav) reportsNav.style.display = "flex";
      reportsEmpty.style.display = "none";
      reportCursor = Math.min(Math.max(reportCursor, 0), list.length - 1);
      if (reportsCounter) {
        reportsCounter.textContent = `${reportCursor + 1} de ${list.length}`;
      }
      if (reportsPrevBtn) reportsPrevBtn.disabled = reportCursor <= 0;
      if (reportsNextBtn) reportsNextBtn.disabled = reportCursor >= list.length - 1;

      const report = list[reportCursor];
      const reporterName = getUserDisplayName(report.reporter);
      const targetUserName = getUserDisplayName(report.reported_user);
      const listingTitle = report.listing?.title || "Anúncio removido";
      const listingServer = report.listing_server_name ? ` (${report.listing_server_name})` : "";
      const targetLabel = report.target_type === "listing"
        ? `Anúncio: ${listingTitle}${listingServer}`
        : `Perfil: ${targetUserName}`;

      const card = document.createElement("div");
      card.className = "notice";
      card.style.display = "grid";
      card.style.gap = "8px";
      const evidence = Array.isArray(report.evidence_images) ? report.evidence_images.filter(Boolean) : [];
      const evidenceHtml = evidence.length > 0
        ? `
          <div style="display:grid;gap:6px;">
            <strong style="font-size:12px;color:#0f2557;">Anexos da denúncia</strong>
            <div style="display:flex;gap:8px;flex-wrap:wrap;">
              ${evidence.map((url, index) => `<a href="${encodeURI(url)}" target="_blank" rel="noopener"><img src="${encodeURI(url)}" alt="Anexo ${index + 1}" style="width:72px;height:72px;object-fit:cover;border-radius:10px;border:1px solid var(--border);" /></a>`).join("")}
            </div>
          </div>
        `
        : "";
      const listingLinkHtml = report.target_type === "listing" && report.listing_id
        ? `<div class="muted">Link do anúncio: <a class="link-ghost" href="listing.html?id=${encodeURIComponent(report.listing_id)}" target="_blank" rel="noopener">Abrir anúncio</a></div>`
        : "";
      const moderationNoteHtml = report.target_type === "listing"
        ? `
          <div style="display:grid;gap:6px;">
            <label for="report-note-${report.id}" style="font-size:12px;color:#0f2557;font-weight:600;">Motivo da exclusão do anúncio</label>
            <textarea id="report-note-${report.id}" data-report-note rows="3" placeholder="Explique por que o anúncio está sendo removido." style="width:100%;border:1px solid var(--border);border-radius:10px;padding:8px 10px;font:inherit;resize:vertical;min-height:76px;"></textarea>
          </div>
        `
        : "";
      card.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
          <strong>${report.target_type === "listing" ? "Denúncia de anúncio" : "Denúncia de perfil"}</strong>
          <span class="pill">pending</span>
        </div>
        <div class="muted">Denunciante: ${escapeHtml(reporterName)}</div>
        <div class="muted">${escapeHtml(targetLabel)}</div>
        ${listingLinkHtml}
        <div class="muted">Enviado em: ${escapeHtml(formatDateTime(report.created_at))}</div>
        <div style="padding:8px 10px;border:1px solid var(--border);border-radius:10px;background:rgba(15,37,87,0.03);">${escapeHtml(report.reason || "")}</div>
        ${evidenceHtml}
        ${moderationNoteHtml}
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button class="btn secondary" data-report-action="handled" data-report-id="${report.id}" style="flex:1;">Tratado</button>
          ${report.target_type === "listing" && report.listing_id ? `<button class="btn secondary" data-report-action="delete-listing" data-report-id="${report.id}" style="flex:1;">Excluir anúncio</button>` : ""}
          ${report.resolved_user_id ? `<button class="btn secondary" data-report-action="ban-user" data-report-id="${report.id}" style="flex:1;">Banir usuário</button>` : ""}
        </div>
      `;
      reportsList.appendChild(card);
    }

    function setReportButtonsProcessing(card, clickedAction, processing) {
      if (!card) return;
      const buttons = card.querySelectorAll("button[data-report-action]");
      if (!buttons || buttons.length === 0) return;
      buttons.forEach((button) => {
        if (!button.dataset.defaultText) {
          button.dataset.defaultText = button.textContent || "";
        }
      });

      if (processing) {
        buttons.forEach((button) => {
          button.disabled = true;
          if (button.getAttribute("data-report-action") === clickedAction) {
            button.textContent = "Processando...";
          }
        });
        return;
      }

      buttons.forEach((button) => {
        button.disabled = false;
        button.textContent = button.dataset.defaultText || button.textContent;
      });
    }

    function setDecisionButtonsProcessing(card, clickedAction, processing) {
      if (!card) return;
      const approveBtn = card.querySelector('button[data-action="approve"]');
      const rejectBtn = card.querySelector('button[data-action="reject"]');
      if (!approveBtn || !rejectBtn) return;

      if (!approveBtn.dataset.defaultText) {
        approveBtn.dataset.defaultText = approveBtn.textContent || "Aprovar";
      }
      if (!rejectBtn.dataset.defaultText) {
        rejectBtn.dataset.defaultText = rejectBtn.textContent || "Recusar";
      }

      if (processing) {
        approveBtn.disabled = true;
        rejectBtn.disabled = true;
        if (clickedAction === "approve") {
          approveBtn.textContent = "Processando...";
        } else if (clickedAction === "reject") {
          rejectBtn.textContent = "Processando...";
        }
        return;
      }

      approveBtn.disabled = false;
      rejectBtn.disabled = false;
      approveBtn.textContent = approveBtn.dataset.defaultText;
      rejectBtn.textContent = rejectBtn.dataset.defaultText;
    }

    requestsPrevBtn?.addEventListener("click", () => {
      if (requestCursor <= 0) return;
      requestCursor -= 1;
      renderRequests(requestCache);
    });

    requestsNextBtn?.addEventListener("click", () => {
      if (requestCursor >= requestCache.length - 1) return;
      requestCursor += 1;
      renderRequests(requestCache);
    });

    reportsPrevBtn?.addEventListener("click", () => {
      if (reportCursor <= 0) return;
      reportCursor -= 1;
      renderReports(reportCache);
    });

    reportsNextBtn?.addEventListener("click", () => {
      if (reportCursor >= reportCache.length - 1) return;
      reportCursor += 1;
      renderReports(reportCache);
    });

    requestsList?.addEventListener("click", async (event) => {
      const btn = event.target.closest("button[data-action]");
      if (!btn) return;
      if (!profile?.is_admin) {
        requestsStatus.textContent = "Apenas admins podem decidir.";
        return;
      }
      const id = btn.getAttribute("data-id");
      const action = btn.getAttribute("data-action");
      if (action === "prefill") {
        const req = requestCache.find((r) => String(r.id) === String(id));
        if (req) {
          enterEditMode(req);
          requestsStatus.textContent = "Formulário carregado para edição.";
        }
        return;
      }
      const approved = action === "approve";
      let note = "";
      if (!approved) {
        note = window.prompt("Motivo da recusa? (opcional)", "") || "";
      }
      const card = btn.closest(".notice");
      setDecisionButtonsProcessing(card, action, true);
      try {
        requestsStatus.textContent = "Processando...";
        const { data: sessionData } = await supabase.auth.getSession();
        const token = sessionData.session?.access_token || "";
        const { data: approveData, error: approveErr } = await supabase.functions.invoke("game_approve", {
          body: { requestId: id, approved, note },
          headers: token
            ? {
                Authorization: `Bearer ${token}`,
                apikey: SUPABASE_ANON_KEY
              }
            : {}
        });
        if (approveErr || !approveData?.ok) {
          const errMsg = approveErr?.context?.response?.error ?? approveData?.error ?? approveErr?.message;
          throw new Error(errMsg || "Erro ao processar solicitação.");
        }
        await fetchRequests();
        requestsStatus.textContent = approved ? "Solicitação aprovada." : "Solicitação recusada.";
      } catch (err) {
        console.error(err);
        requestsStatus.textContent = err?.message || "Erro ao processar solicitação.";
        setDecisionButtonsProcessing(card, action, false);
      }
    });

    reportsList?.addEventListener("click", async (event) => {
      const btn = event.target.closest("button[data-report-action]");
      if (!btn) return;
      if (!profile?.is_admin) {
        reportsStatus.textContent = "Apenas admins podem moderar denúncias.";
        return;
      }
      const reportId = btn.getAttribute("data-report-id");
      const action = btn.getAttribute("data-report-action");
      const report = reportCache.find((item) => String(item.id) === String(reportId));
      if (!report || !action) return;

      const card = btn.closest(".notice");
      setReportButtonsProcessing(card, action, true);
      try {
        reportsStatus.textContent = "Processando denúncia...";
        const noteInput = card?.querySelector("textarea[data-report-note]");
        const note = String(noteInput?.value || "").trim();
        if (action === "delete-listing" && note.length < 10) {
          setReportButtonsProcessing(card, action, false);
          reportsStatus.textContent = "Informe o motivo da exclusão com pelo menos 10 caracteres.";
          noteInput?.focus();
          return;
        }
        if (action === "ban-user") {
          if (!report.resolved_user_id) {
            throw new Error("Não foi possível identificar o usuário denunciado.");
          }
          const confirmBan = window.confirm("Confirma o banimento deste usuário? Os anúncios dele serão removidos.");
          if (!confirmBan) {
            setReportButtonsProcessing(card, action, false);
            reportsStatus.textContent = "Ação cancelada.";
            return;
          }
        }
        const { data: sessionData } = await supabase.auth.getSession();
        const token = sessionData.session?.access_token || "";
        const { data: moderateData, error: moderateErr } = await supabase.functions.invoke("report_moderate", {
          body: {
            reportId: report.id,
            action,
            note,
            userToken: token,
          },
          headers: token
            ? {
                Authorization: `Bearer ${token}`,
                apikey: SUPABASE_ANON_KEY,
              }
            : {},
        });
        if (moderateErr || !moderateData?.ok) {
          const errMsg = moderateErr?.context?.response?.error ?? moderateData?.error ?? moderateErr?.message;
          throw new Error(errMsg || "Erro ao tratar denúncia.");
        }
        await fetchReports();
        if (action === "delete-listing") {
          if (moderateData?.emailSent === false) {
            reportsStatus.textContent = moderateData?.emailError
              ? `Anúncio excluído, mas o e-mail falhou: ${moderateData.emailError}`
              : "Anúncio excluído, mas não foi possível confirmar o envio do e-mail.";
          } else {
            reportsStatus.textContent = "Anúncio excluído, denúncia tratada e e-mail enviado ao anunciante.";
          }
        } else if (action === "ban-user") {
          reportsStatus.textContent = "Usuário banido e denúncia tratada.";
        } else {
          reportsStatus.textContent = "Denúncia tratada.";
        }
      } catch (err) {
        console.error(err);
        reportsStatus.textContent = err?.message || "Erro ao tratar denúncia.";
        setReportButtonsProcessing(card, action, false);
      }
    });

    serverLogoInput?.addEventListener("change", handleLogoChange);
    clearEditBtn?.addEventListener("click", () => {
      serverForm?.reset();
      enterEditMode(null);
    });

    // Inicializa
    try {
      ensureClient();
      refreshSession();
    } catch (err) {
      console.warn(err.message);
    }
  </script>
</body>
</html>
