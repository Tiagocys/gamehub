<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://gamehub-d35.pages.dev/img/meta.png" />
  <meta property="og:image:alt" content="Gimerr" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://gamehub-d35.pages.dev/img/meta.png" />
  <meta name="twitter:image:alt" content="Gimerr" />
  <link rel="icon" type="image/png" href="img/favicon.png" />
  <title>Gimerr - Área de parceiros</title>
  <link rel="stylesheet" href="css/global.css" />
  <style id="partner-guard-style">html{visibility:hidden;}</style>
  <script>
    (() => {
      try {
        const hasSession = localStorage.getItem("gimerr-auth-token") || localStorage.getItem("gimerr-auth-session");
        if (!hasSession) {
          window.location.replace("index.html");
        }
      } catch (_err) {
        window.location.replace("index.html");
      }
    })();
  </script>
  <style>
    .partner-grid {
      display: grid;
      gap: 16px;
    }

    .partner-grid .hero-card {
      display: grid;
      gap: 10px;
    }

    .partner-status-list {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .partner-status-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(12, 21, 51, 0.03);
      padding: 10px 12px;
      display: grid;
      gap: 4px;
    }

    .partner-status-item small {
      color: var(--muted);
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.04em;
      font-weight: 700;
    }

    .partner-status-item strong {
      color: var(--ink);
      font-size: 15px;
    }

    .partner-server-list {
      display: grid;
      gap: 10px;
    }

    .partner-server-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(12, 21, 51, 0.03);
      padding: 12px;
      display: grid;
      gap: 6px;
    }

    .partner-server-logo {
      width: 56px;
      height: 56px;
      border-radius: 10px;
      border: 1px solid var(--border);
      object-fit: contain;
      background: #fff;
      flex-shrink: 0;
    }

    .partner-server-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .partner-server-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .partner-feedback {
      min-height: 18px;
      color: var(--muted);
      font-size: 13px;
    }

    .partner-server-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .partner-server-desc {
      white-space: pre-wrap;
      font-size: 13px;
      color: var(--muted);
      margin: 0;
    }

    .partner-edit-modal {
      position: fixed;
      inset: 0;
      z-index: 12000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      background: rgba(12, 21, 51, 0.6);
    }

    .partner-edit-modal.open {
      display: flex;
    }

    .partner-edit-card {
      width: min(640px, 100%);
      max-height: min(92vh, 760px);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      display: grid;
      grid-template-rows: auto 1fr;
      overflow: hidden;
    }

    .partner-edit-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px 10px;
      border-bottom: 1px solid var(--border);
      gap: 10px;
    }

    .partner-edit-head h3 {
      margin: 0;
      font-size: 20px;
    }

    .partner-edit-close {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--ink);
      font-size: 18px;
      cursor: pointer;
    }

    .partner-edit-form {
      display: grid;
      gap: 12px;
      padding: 14px 16px 18px;
      overflow-y: auto;
    }

    .partner-edit-field {
      display: grid;
      gap: 6px;
    }

    .partner-edit-field label {
      font-size: 13px;
      font-weight: 700;
      color: var(--ink);
    }

    .partner-edit-field input,
    .partner-edit-field textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      font: inherit;
      color: var(--ink);
      background: #fff;
      resize: vertical;
    }

    .partner-edit-preview {
      width: 96px;
      height: 96px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(12, 21, 51, 0.04);
      object-fit: contain;
      display: block;
    }

    .partner-edit-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .partner-edit-feedback {
      font-size: 13px;
      min-height: 18px;
      color: var(--muted);
    }

    @media (max-width: 760px) {
      .partner-status-list {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div id="page-loader" class="page-loader">
    <img src="img/logo.png" alt="Carregando" />
  </div>
  <div class="page">
    <site-navbar></site-navbar>

    <main class="section partner-grid">
      <section class="hero-card">
        <h2>Painel de parceiro</h2>
        <p class="helper">Gerencie seus games e acompanhe seus ganhos.</p>
      </section>

      <section class="hero-card">
        <div class="partner-status-list">
          <div class="partner-status-item">
            <small>Conta Connect</small>
            <strong id="partner-account-id">Ainda não criada</strong>
          </div>
          <div class="partner-status-item">
            <small>Recebimentos habilitados</small>
            <strong id="partner-payouts">Não</strong>
          </div>
          <div class="partner-status-item">
            <small>Esperado para recebimento</small>
            <strong id="partner-expected-amount">R$ 0,00</strong>
          </div>
          <div class="partner-status-item">
            <small>Disponível para repasse</small>
            <strong id="partner-available-amount">R$ 0,00</strong>
          </div>
          <div class="partner-status-item">
            <small>Em período ativo</small>
            <strong id="partner-pending-amount">R$ 0,00</strong>
          </div>
          <div class="partner-status-item">
            <small>Destaques ativos</small>
            <strong id="partner-active-highlights-count">0</strong>
          </div>
        </div>
        <div class="inline-actions">
          <button id="start-connect-btn" class="btn btn-primary" type="button">Iniciar onboarding Connect</button>
          <button id="refresh-connect-btn" class="btn btn-ghost" type="button">Atualizar status</button>
          <a class="btn btn-ghost" href="politica-parceiros.html">Políticas de parceiros</a>
          <a class="btn btn-ghost" href="terms.html">Termos de uso</a>
        </div>
        <p id="connect-feedback" class="partner-feedback"></p>
      </section>

      <section class="hero-card">
        <div class="partner-server-head">
          <h3>Servidores vinculados</h3>
          <span id="partner-servers-count" class="pill">0 servidores</span>
        </div>
        <div id="partner-server-list" class="partner-server-list"></div>
        <p id="partner-servers-empty" class="helper" style="display:none;">Nenhum servidor vinculado ao seu usuário no momento.</p>
      </section>
    </main>

    <div id="partner-edit-modal" class="partner-edit-modal" aria-hidden="true">
      <div class="partner-edit-card">
        <div class="partner-edit-head">
          <h3>Editar servidor</h3>
          <button id="partner-edit-close" class="partner-edit-close" type="button" aria-label="Fechar">×</button>
        </div>
        <form id="partner-edit-form" class="partner-edit-form">
          <input id="partner-edit-server-id" type="hidden" />
          <div class="partner-edit-field">
            <label for="partner-edit-name">Nome do servidor</label>
            <input id="partner-edit-name" maxlength="120" required />
          </div>
          <div class="partner-edit-field">
            <label for="partner-edit-site">Site oficial</label>
            <input id="partner-edit-site" placeholder="https://seu-servidor.com" required />
          </div>
          <div class="partner-edit-field">
            <label for="partner-edit-discord">Discord oficial</label>
            <input id="partner-edit-discord" placeholder="https://discord.gg/seu-servidor" />
          </div>
          <div class="partner-edit-field">
            <label for="partner-edit-description">Descrição</label>
            <textarea id="partner-edit-description" rows="4" maxlength="2000" placeholder="Descreva rapidamente o servidor."></textarea>
          </div>
          <div class="partner-edit-field">
            <label for="partner-edit-logo-file">Logo (opcional)</label>
            <input id="partner-edit-logo-file" type="file" accept="image/png,image/jpeg,image/webp" />
            <span class="helper">A imagem será convertida para WebP antes do envio.</span>
          </div>
          <img id="partner-edit-logo-preview" class="partner-edit-preview" alt="Prévia da logo do servidor" style="display:none;" />
          <div class="partner-edit-actions">
            <button id="partner-edit-submit" class="btn btn-primary" type="submit">Salvar alterações</button>
            <button id="partner-edit-cancel" class="btn btn-ghost" type="button">Cancelar</button>
          </div>
          <div id="partner-edit-feedback" class="partner-edit-feedback"></div>
        </form>
      </div>
    </div>

    <site-footer></site-footer>
  </div>

  <script src="env.js"></script>
  <script src="js/site-navbar.js"></script>
  <script src="js/site-footer.js"></script>
  <script type="module">
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2.40.0";

    await (window.__NAVBAR_READY__ || Promise.resolve());

    const env = window.__ENV || {};
    const SUPABASE_URL = env.SUPABASE_URL || "YOUR_SUPABASE_URL";
    const SUPABASE_ANON_KEY = env.SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";
    const R2_PUBLIC_URL = env.R2_PUBLIC_URL || "";

    const authBtn = document.getElementById("auth-btn");
    const userMenu = document.getElementById("user-menu");
    const avatarBtn = document.getElementById("avatar-btn");
    const avatarImg = document.getElementById("avatar-img");
    const logoutBtn = document.getElementById("logout-btn");
    const createListingBtn = document.getElementById("create-listing-btn");
    const menuCreateListing = document.getElementById("menu-create-listing");
    const profileLink = document.getElementById("profile-link");

    const partnerAccountId = document.getElementById("partner-account-id");
    const partnerPayouts = document.getElementById("partner-payouts");
    const connectFeedback = document.getElementById("connect-feedback");
    const startConnectBtn = document.getElementById("start-connect-btn");
    const refreshConnectBtn = document.getElementById("refresh-connect-btn");
    const partnerServersCount = document.getElementById("partner-servers-count");
    const partnerServerList = document.getElementById("partner-server-list");
    const partnerServersEmpty = document.getElementById("partner-servers-empty");
    const partnerExpectedAmount = document.getElementById("partner-expected-amount");
    const partnerAvailableAmount = document.getElementById("partner-available-amount");
    const partnerPendingAmount = document.getElementById("partner-pending-amount");
    const partnerActiveHighlightsCount = document.getElementById("partner-active-highlights-count");
    const partnerEditModal = document.getElementById("partner-edit-modal");
    const partnerEditForm = document.getElementById("partner-edit-form");
    const partnerEditClose = document.getElementById("partner-edit-close");
    const partnerEditCancel = document.getElementById("partner-edit-cancel");
    const partnerEditServerId = document.getElementById("partner-edit-server-id");
    const partnerEditName = document.getElementById("partner-edit-name");
    const partnerEditSite = document.getElementById("partner-edit-site");
    const partnerEditDiscord = document.getElementById("partner-edit-discord");
    const partnerEditDescription = document.getElementById("partner-edit-description");
    const partnerEditLogoFile = document.getElementById("partner-edit-logo-file");
    const partnerEditLogoPreview = document.getElementById("partner-edit-logo-preview");
    const partnerEditFeedback = document.getElementById("partner-edit-feedback");
    const partnerEditSubmit = document.getElementById("partner-edit-submit");

    const pageLoader = document.getElementById("page-loader");
    let loaderDone = false;
    let windowLoaded = false;
    let avatarReady = false;
    let contentReady = false;

    function hideLoader() {
      if (loaderDone || !pageLoader) return;
      if (!windowLoaded || !avatarReady || !contentReady) return;
      loaderDone = true;
      pageLoader.classList.add("hidden");
      pageLoader.remove();
    }

    function markAvatarReady() {
      avatarReady = true;
      hideLoader();
    }

    function markContentReady() {
      contentReady = true;
      hideLoader();
    }

    window.addEventListener("load", () => {
      windowLoaded = true;
      hideLoader();
    });

    let supabase;
    let currentUser = null;
    let currentProfile = null;
    let avatarLoaded = false;
    let currentServers = [];
    let currentEditBannerUrl = "";
    let editLogoPreviewObjectUrl = null;
    const LOGO_MAX_BYTES = 5 * 1024 * 1024;
    const LOGO_MAX_DIMENSION = 1400;
    const LOGO_WEBP_QUALITY = 0.84;
    if (avatarImg) avatarImg.referrerPolicy = "no-referrer";

    function revealPage() {
      document.documentElement.style.visibility = "visible";
      const guard = document.getElementById("partner-guard-style");
      if (guard) guard.remove();
    }

    function escapeHtml(value) {
      return String(value || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function ensureHttpsPrefix(raw) {
      const trimmed = String(raw || "").trim();
      if (!trimmed) return "";
      const withoutProtocol = trimmed.replace(/^https?:\/\//i, "");
      return `https://${withoutProtocol}`;
    }

    function normalizeWebsite(raw) {
      const withProtocol = ensureHttpsPrefix(raw);
      if (!withProtocol) return "";
      try {
        const parsed = new URL(withProtocol);
        parsed.protocol = "https:";
        parsed.hash = "";
        return parsed.toString();
      } catch (_err) {
        return "";
      }
    }

    function normalizeDiscordInvite(raw) {
      const withProtocol = ensureHttpsPrefix(raw);
      if (!withProtocol) return "";
      try {
        const parsed = new URL(withProtocol);
        if (parsed.hostname.toLowerCase() !== "discord.gg") return "";
        parsed.protocol = "https:";
        parsed.hash = "";
        if (!parsed.pathname || parsed.pathname === "/") return "";
        parsed.pathname = parsed.pathname.replace(/\/+$/, "");
        return parsed.toString();
      } catch (_err) {
        return "";
      }
    }

    function resolveMediaUrl(raw) {
      const value = String(raw || "").trim();
      if (!value) return "";
      if (/^https?:\/\//i.test(value)) {
        return normalizeR2PublicUrl(value);
      }
      const normalized = value.replace(/^\/+/, "");
      if (normalized.startsWith("storage/v1/object/")) {
        return `${SUPABASE_URL.replace(/\/$/, "")}/${normalized}`;
      }
      if (normalized.startsWith("server_logos/")) {
        return `${SUPABASE_URL.replace(/\/$/, "")}/storage/v1/object/public/${normalized}`;
      }
      if (R2_PUBLIC_URL) {
        return `${R2_PUBLIC_URL.replace(/\/$/, "")}/${normalized}`;
      }
      return normalized;
    }

    function normalizeR2PublicUrl(urlString) {
      try {
        const url = new URL(urlString);
        if (!url.hostname.endsWith(".r2.cloudflarestorage.com")) return urlString;
        const pathParts = url.pathname.split("/").filter(Boolean);
        if (pathParts.length < 2) return urlString;
        let bucket = pathParts[0];
        const keyParts = pathParts.slice(1);
        if (R2_PUBLIC_URL) {
          const publicPath = new URL(R2_PUBLIC_URL).pathname.split("/").filter(Boolean);
          if (publicPath.length > 0) {
            bucket = publicPath[0];
          }
        }
        if (!bucket || keyParts.length === 0) return urlString;
        const accountId = url.hostname.split(".")[0];
        const base = R2_PUBLIC_URL ? R2_PUBLIC_URL.replace(/\/$/, "") : `https://${bucket}.${accountId}.r2.dev`;
        return `${base}/${keyParts.join("/")}`;
      } catch (_err) {
        return urlString;
      }
    }

    function parseStoragePath(urlString) {
      try {
        const url = new URL(urlString);
        const marker = "/storage/v1/object/";
        const idx = url.pathname.indexOf(marker);
        if (idx === -1) return null;
        const rest = url.pathname.substring(idx + marker.length);
        const parts = rest.split("/");
        if (parts.length === 0) return null;
        let bucket = parts[0];
        let pathParts = parts.slice(1);
        if (bucket === "public" || bucket === "authenticated" || bucket === "sign") {
          bucket = parts[1];
          pathParts = parts.slice(2);
        }
        if (!bucket || pathParts.length === 0) return null;
        return { bucket, path: pathParts.join("/") };
      } catch (_err) {
        return null;
      }
    }

    async function resolveServerBannerUrl(raw) {
      const normalized = resolveMediaUrl(raw);
      if (!normalized) return "";
      const parsed = parseStoragePath(normalized);
      if (!parsed) return normalized;
      try {
        ensureClient();
        const { data, error } = await supabase.storage
          .from(parsed.bucket)
          .createSignedUrl(parsed.path, 60 * 60 * 6);
        if (error) throw error;
        return data?.signedUrl || normalized;
      } catch (_err) {
        return normalized;
      }
    }

    function setModalFeedback(message, isError = false) {
      if (!partnerEditFeedback) return;
      partnerEditFeedback.textContent = message || "";
      partnerEditFeedback.style.color = isError ? "#c62828" : "var(--muted)";
    }

    function clearLogoPreviewObjectUrl() {
      if (editLogoPreviewObjectUrl) {
        URL.revokeObjectURL(editLogoPreviewObjectUrl);
        editLogoPreviewObjectUrl = null;
      }
    }

    function setLogoPreview(url) {
      if (!partnerEditLogoPreview) return;
      if (!url) {
        partnerEditLogoPreview.removeAttribute("src");
        partnerEditLogoPreview.style.display = "none";
        partnerEditLogoPreview.dataset.fallbackApplied = "";
        return;
      }
      partnerEditLogoPreview.dataset.fallbackApplied = "";
      partnerEditLogoPreview.src = url;
      partnerEditLogoPreview.style.display = "block";
    }

    function closeEditModal() {
      clearLogoPreviewObjectUrl();
      if (partnerEditModal) {
        partnerEditModal.classList.remove("open");
        partnerEditModal.setAttribute("aria-hidden", "true");
      }
      if (partnerEditForm) partnerEditForm.reset();
      setLogoPreview("");
      setModalFeedback("");
      currentEditBannerUrl = "";
    }

    function openEditModal(serverId) {
      const server = currentServers.find((item) => String(item.id) === String(serverId));
      if (!server) return;
      if (!partnerEditModal || !partnerEditForm) return;

      clearLogoPreviewObjectUrl();
      currentEditBannerUrl = resolveMediaUrl(server.banner_url || "");
      partnerEditServerId.value = String(server.id || "");
      partnerEditName.value = String(server.name || "");
      partnerEditSite.value = String(server.official_site || "");
      partnerEditDiscord.value = String(server.discord_invite || "");
      partnerEditDescription.value = String(server.description || "");
      partnerEditLogoFile.value = "";
      setLogoPreview(currentEditBannerUrl);
      setModalFeedback("");
      partnerEditSubmit.disabled = false;
      partnerEditSubmit.textContent = "Salvar alterações";
      partnerEditModal.classList.add("open");
      partnerEditModal.setAttribute("aria-hidden", "false");
      setTimeout(() => partnerEditName?.focus(), 0);
    }

    function ensureClient() {
      if (!SUPABASE_URL || SUPABASE_URL.startsWith("YOUR_") || !SUPABASE_ANON_KEY || SUPABASE_ANON_KEY.startsWith("YOUR_")) {
        connectFeedback.textContent = "Supabase não configurado.";
        authBtn.disabled = true;
        throw new Error("Supabase não configurado");
      }
      if (!supabase) {
        supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: {
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: true,
            storageKey: "gimerr-auth-token",
          },
        });
        supabase.auth.onAuthStateChange((_event, session) => {
          currentUser = session?.user || null;
          updateAuthUI();
        });
      }
      return supabase;
    }

    function updateAuthUI() {
      if (!authBtn) return;
      authBtn.disabled = false;
      if (currentUser) {
        authBtn.style.display = "none";
        if (userMenu) userMenu.style.display = "inline-flex";
        if (profileLink) profileLink.href = `user.html?id=${encodeURIComponent(currentUser.id)}`;
        if (createListingBtn) createListingBtn.style.display = "inline-flex";
        if (menuCreateListing) menuCreateListing.style.display = "";
        loadUserAvatar();
        return;
      }
      authBtn.style.display = "inline-flex";
      if (userMenu) userMenu.style.display = "none";
      if (profileLink) profileLink.href = "profile.html";
      if (createListingBtn) createListingBtn.style.display = "none";
      if (menuCreateListing) menuCreateListing.style.display = "none";
      avatarLoaded = false;
      markAvatarReady();
    }

    async function setAvatarImage(src) {
      if (!avatarImg) return;
      const finalSrc = src || "img/avatar.svg";
      avatarImg.src = finalSrc;
      try {
        await avatarImg.decode();
      } catch (_err) {
        if (finalSrc !== "img/avatar.svg") {
          avatarImg.src = "img/avatar.svg";
          try {
            await avatarImg.decode();
          } catch (_innerErr) {
            // ignore
          }
        }
      } finally {
        markAvatarReady();
      }
    }

    async function loadUserAvatar() {
      if (!avatarImg || !currentUser || avatarLoaded) return;
      try {
        ensureClient();
        const { data } = await supabase
          .from("users")
          .select("avatar_url")
          .eq("id", currentUser.id)
          .single();
        let avatar = data?.avatar_url;
        if (!avatar) {
          const { data: authData } = await supabase.auth.getUser();
          const meta = authData?.user?.user_metadata || {};
          avatar = meta.avatar_url || meta.picture || currentUser.user_metadata?.avatar_url || currentUser.user_metadata?.picture;
        }
        await setAvatarImage(avatar);
      } catch (_err) {
        try {
          const { data: authData } = await supabase.auth.getUser();
          const meta = authData?.user?.user_metadata || {};
          const avatar = meta.avatar_url || meta.picture || currentUser.user_metadata?.avatar_url || currentUser.user_metadata?.picture;
          await setAvatarImage(avatar);
        } catch (_innerErr) {
          await setAvatarImage("img/avatar.svg");
        }
      } finally {
        avatarLoaded = true;
      }
    }

    async function handleAuthClick() {
      try {
        ensureClient();
        authBtn.disabled = true;
        window.location.href = "index.html";
      } catch (_err) {
        // ignore
      }
    }

    function formatDateTime(value) {
      if (!value) return "-";
      try {
        return new Date(value).toLocaleString("pt-BR");
      } catch (_err) {
        return String(value);
      }
    }

    function formatBRL(value) {
      return new Intl.NumberFormat("pt-BR", {
        style: "currency",
        currency: "BRL",
      }).format(Number(value || 0));
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function toSafeDate(value) {
      if (!value) return null;
      const parsed = new Date(value);
      if (Number.isNaN(parsed.getTime())) return null;
      return parsed;
    }

    async function resolveFunctionErrorMessage(error, data, fallbackMessage) {
      if (data?.error) return String(data.error);
      if (!error) return fallbackMessage;
      try {
        const context = error.context;
        if (context) {
          const json = await context.clone().json().catch(() => null);
          if (json?.error) return String(json.error);
          const text = await context.clone().text().catch(() => "");
          if (text) return String(text);
        }
      } catch (_err) {
        // ignore parse errors
      }
      return error?.message || fallbackMessage;
    }

    async function requestServerLogoSignedUpload(file) {
      ensureClient();
      const { data } = await supabase.auth.getSession();
      const token = data.session?.access_token;
      if (!token) {
        throw new Error("Sessão expirada. Faça login novamente.");
      }

      const extension = (file.name.split(".").pop() || "").toLowerCase();
      const response = await fetch(`${SUPABASE_URL}/functions/v1/r2_sign_upload`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
          apikey: SUPABASE_ANON_KEY,
        },
        body: JSON.stringify({
          contentType: file.type || "application/octet-stream",
          extension,
          userToken: token,
          assetType: "server",
        }),
      });

      if (!response.ok) {
        let message = "Erro ao solicitar upload da logo.";
        try {
          const payload = await response.json();
          message = payload?.error || message;
        } catch (_err) {
          const text = await response.text().catch(() => "");
          if (text) message = text;
        }
        throw new Error(message);
      }
      return response.json();
    }

    async function convertLogoToWebp(file) {
      if (!file.type || !file.type.startsWith("image/")) {
        throw new Error("Selecione uma imagem válida para a logo.");
      }
      const bitmap = await createImageBitmap(file);
      const maxSide = Math.max(bitmap.width, bitmap.height);
      const scale = Math.min(1, LOGO_MAX_DIMENSION / maxSide);
      const canvas = document.createElement("canvas");
      canvas.width = Math.max(1, Math.round(bitmap.width * scale));
      canvas.height = Math.max(1, Math.round(bitmap.height * scale));
      const ctx = canvas.getContext("2d");
      if (!ctx) throw new Error("Falha ao processar imagem.");
      ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/webp", LOGO_WEBP_QUALITY));
      if (!blob) throw new Error("Falha ao converter imagem para WebP.");
      const baseName = file.name.replace(/\.[^.]+$/, "") || "logo";
      return new File([blob], `${baseName}.webp`, { type: "image/webp" });
    }

    async function uploadServerLogo(file) {
      const webpFile = await convertLogoToWebp(file);
      if (webpFile.size > LOGO_MAX_BYTES) {
        throw new Error("A logo excede 5MB após conversão.");
      }
      const signed = await requestServerLogoSignedUpload(webpFile);
      const uploadRes = await fetch(signed.uploadUrl, {
        method: "PUT",
        headers: {
          "Content-Type": webpFile.type || "application/octet-stream",
        },
        body: webpFile,
      });
      if (!uploadRes.ok) {
        const body = await uploadRes.text().catch(() => "");
        throw new Error(body || "Falha ao enviar logo para o storage.");
      }
      return signed.publicUrl;
    }

    async function saveServerSettings(event) {
      event.preventDefault();
      try {
        ensureClient();
        setModalFeedback("");
        partnerEditSubmit.disabled = true;
        partnerEditSubmit.textContent = "Salvando...";

        const serverId = String(partnerEditServerId.value || "").trim();
        const name = String(partnerEditName.value || "").trim();
        const officialSite = normalizeWebsite(partnerEditSite.value);
        const discordRaw = String(partnerEditDiscord.value || "").trim();
        const discordInvite = discordRaw ? normalizeDiscordInvite(discordRaw) : "";
        const description = String(partnerEditDescription.value || "").trim();
        const logoFile = partnerEditLogoFile.files?.[0] || null;

        if (!serverId) throw new Error("Servidor inválido.");
        if (!name) throw new Error("Informe o nome do servidor.");
        if (!officialSite) throw new Error("Informe um site oficial válido.");
        if (discordRaw && !discordInvite) throw new Error("Convite Discord inválido. Use https://discord.gg/...");
        if (logoFile && logoFile.size > LOGO_MAX_BYTES) throw new Error("A logo deve ter no máximo 5MB.");

        let bannerUrl = currentEditBannerUrl || "";
        if (logoFile) {
          setModalFeedback("Enviando nova logo...");
          bannerUrl = await uploadServerLogo(logoFile);
        }

        const { data: sessionData } = await supabase.auth.getSession();
        const token = sessionData.session?.access_token || "";
        if (!token) throw new Error("Sessão expirada. Faça login novamente.");

        const updateBody = {
          serverId,
          name,
          officialSite,
          discordInvite: discordInvite || null,
          description: description || null,
        };
        if (logoFile) {
          updateBody.bannerUrl = bannerUrl || null;
        }

        const { data, error } = await supabase.functions.invoke("server_update_settings", {
          body: updateBody,
          headers: {
            Authorization: `Bearer ${token}`,
            apikey: SUPABASE_ANON_KEY,
          },
        });
        if (error || !data?.ok) {
          const message = await resolveFunctionErrorMessage(error, data, "Erro ao salvar servidor.");
          throw new Error(message);
        }

        connectFeedback.textContent = "Servidor atualizado com sucesso.";
        const refreshedServers = await fetchOwnedServers();
        renderServers(refreshedServers);
        closeEditModal();
      } catch (err) {
        console.error(err);
        setModalFeedback(err?.message || "Erro ao salvar servidor.", true);
      } finally {
        partnerEditSubmit.disabled = false;
        partnerEditSubmit.textContent = "Salvar alterações";
      }
    }

    function isMissingPartnerPayoutTableError(error) {
      if (!error) return false;
      if (error.code === "42P01" || error.code === "42703") return true;
      const message = String(error.message || "").toLowerCase();
      return message.includes("partner_payout_events");
    }

    function isMissingAdminBeneficiaryColumnError(error) {
      if (!error) return false;
      return String(error.message || "").includes("admin_beneficiary_id");
    }

    async function fetchPartnerProfile() {
      const fields = "id,email,first_name,last_name,is_partner,stripe_connect_account_id,stripe_connect_charges_enabled,stripe_connect_payouts_enabled,stripe_connect_details_submitted,stripe_connect_onboarded_at";
      let { data, error } = await supabase
        .from("users")
        .select(fields)
        .eq("id", currentUser.id)
        .single();

      if (error && error.code === "42703") {
        const fallback = await supabase
          .from("users")
          .select("id,email,first_name,last_name")
          .eq("id", currentUser.id)
          .single();
        data = fallback.data
          ? {
              ...fallback.data,
              is_partner: false,
              stripe_connect_account_id: null,
              stripe_connect_charges_enabled: false,
              stripe_connect_payouts_enabled: false,
              stripe_connect_details_submitted: false,
              stripe_connect_onboarded_at: null,
            }
          : null;
        error = fallback.error;
      }
      if (error) throw error;
      return data;
    }

    function renderPartnerProfile(profile) {
      currentProfile = profile;
      partnerAccountId.textContent = profile?.stripe_connect_account_id || "Ainda não criada";
      partnerPayouts.textContent = profile?.stripe_connect_payouts_enabled ? "Sim" : "Não";
    }

    async function fetchPartnerPayoutSummary() {
      try {
        const { data: sessionData } = await supabase.auth.getSession();
        const token = sessionData.session?.access_token || "";
        const { data, error } = await supabase.functions.invoke("partner_payout_summary", {
          body: {},
          headers: token
            ? {
                Authorization: `Bearer ${token}`,
                apikey: SUPABASE_ANON_KEY,
              }
            : {},
        });
        if (!error && data?.ok && data?.summary) {
          return data.summary;
        }
      } catch (_err) {
        // Fallback para cálculo legado abaixo.
      }

      const { data, error } = await supabase
        .from("partner_payout_events")
        .select("expected_net_amount,refunded_net_amount,payout_status,highlight_started_at,highlight_expires_at,currency")
        .eq("owner_user_id", currentUser.id)
        .neq("payout_status", "paid");

      if (isMissingPartnerPayoutTableError(error)) {
        return { unsupported: true };
      }
      if (error) throw error;

      const now = new Date();
      let totalExpected = 0;
      let availableAmount = 0;
      let pendingAmount = 0;
      const count = (data || []).length;

      (data || []).forEach((row) => {
        const payoutStatus = String(row?.payout_status || "").toLowerCase();
        if (payoutStatus === "refunded") return;
        const expected = Number(row?.expected_net_amount || 0);
        const refunded = Number(row?.refunded_net_amount || 0);
        const effective = Math.max(0, Number((expected - refunded).toFixed(2)));
        if (effective <= 0) return;

        totalExpected += effective;
        if (payoutStatus === "eligible") {
          availableAmount += effective;
          return;
        }

        const startedAt = toSafeDate(row?.highlight_started_at);
        const expiresAt = toSafeDate(row?.highlight_expires_at);
        if (startedAt && expiresAt && expiresAt > startedAt) {
          if (now >= expiresAt) {
            availableAmount += effective;
            return;
          }
          if (now <= startedAt) {
            pendingAmount += effective;
            return;
          }
          const progress = clamp(
            (now.getTime() - startedAt.getTime()) / (expiresAt.getTime() - startedAt.getTime()),
            0,
            1,
          );
          const accrued = Number((effective * progress).toFixed(2));
          const pending = Number(Math.max(0, effective - accrued).toFixed(2));
          availableAmount += accrued;
          pendingAmount += pending;
          return;
        }

        if (expiresAt && expiresAt <= now) {
          availableAmount += effective;
        } else {
          pendingAmount += effective;
        }
      });

      return {
        unsupported: false,
        totalExpected: Number(totalExpected.toFixed(2)),
        availableAmount: Number(availableAmount.toFixed(2)),
        pendingAmount: Number(pendingAmount.toFixed(2)),
        count,
      };
    }

    function renderPartnerPayoutSummary(summary) {
      if (!partnerExpectedAmount || !partnerAvailableAmount || !partnerPendingAmount || !partnerActiveHighlightsCount) return;

      if (!summary || summary.unsupported) {
        partnerExpectedAmount.textContent = "-";
        partnerAvailableAmount.textContent = "-";
        partnerPendingAmount.textContent = "-";
        partnerActiveHighlightsCount.textContent = "-";
        return;
      }

      partnerExpectedAmount.textContent = formatBRL(summary.totalExpected);
      partnerAvailableAmount.textContent = formatBRL(summary.availableAmount);
      partnerPendingAmount.textContent = formatBRL(summary.pendingAmount);
      // Este indicador é calculado em renderServers() com base nos servidores vinculados.
    }

    async function fetchOwnedServers() {
      let { data, error } = await supabase
        .from("servers")
        .select("id,name,official_site,status,created_at,discord_invite,description,banner_url,owner_id,admin_beneficiary_id")
        .or(`owner_id.eq.${currentUser.id},admin_beneficiary_id.eq.${currentUser.id}`)
        .order("created_at", { ascending: false });

      if (isMissingAdminBeneficiaryColumnError(error)) {
        const fallback = await supabase
          .from("servers")
          .select("id,name,official_site,status,created_at,discord_invite,description,banner_url,owner_id")
          .eq("owner_id", currentUser.id)
          .order("created_at", { ascending: false });
        data = (fallback.data || []).map((item) => ({ ...item, admin_beneficiary_id: null }));
        error = fallback.error;
      }
      if (error && error.code === "42703") {
        connectFeedback.textContent = "As colunas de vínculo do servidor ainda não existem. Aplique as migrations mais recentes.";
        return [];
      }
      if (error) throw error;
      const servers = data || [];
      if (servers.length === 0) return [];

      const serverIds = servers.map((item) => item.id);
      let listingRows = [];
      const { data: listingsData, error: listingsErr } = await supabase
        .from("listings")
        .select("id,server_id,status,highlight_status")
        .in("server_id", serverIds);
      if (!listingsErr) {
        listingRows = listingsData || [];
      }

      const listingCountMap = new Map();
      const highlightActiveCountMap = new Map();
      listingRows.forEach((row) => {
        const key = String(row.server_id || "");
        if (!key) return;
        listingCountMap.set(key, (listingCountMap.get(key) || 0) + 1);
        if (String(row.status || "") === "active" && String(row.highlight_status || "") === "active") {
          highlightActiveCountMap.set(key, (highlightActiveCountMap.get(key) || 0) + 1);
        }
      });

      const decorated = await Promise.all(servers.map(async (server) => ({
        ...server,
        banner_url: await resolveServerBannerUrl(server.banner_url),
        listing_count: listingCountMap.get(String(server.id)) || 0,
        highlight_active_count: highlightActiveCountMap.get(String(server.id)) || 0,
      })));

      return decorated;
    }

    function renderServers(servers) {
      currentServers = Array.isArray(servers) ? servers : [];
      partnerServerList.innerHTML = "";
      const total = currentServers.length;
      partnerServersCount.textContent = `${total} ${total === 1 ? "servidor" : "servidores"}`;
      const activeHighlightsTotal = (currentServers || []).reduce((sum, server) => {
        return sum + Number(server?.highlight_active_count || 0);
      }, 0);
      if (partnerActiveHighlightsCount) {
        partnerActiveHighlightsCount.textContent = String(activeHighlightsTotal);
      }
      if (total === 0) {
        partnerServersEmpty.style.display = "block";
        return;
      }
      partnerServersEmpty.style.display = "none";
      currentServers.forEach((server) => {
        const safeName = escapeHtml(server.name || "Servidor sem nome");
        const safeStatus = escapeHtml(server.status || "active");
        const gameUrl = `game.html?id=${encodeURIComponent(String(server.id || ""))}`;
        const safeSite = server.official_site ? String(server.official_site) : "";
        const safeDiscord = server.discord_invite ? String(server.discord_invite) : "";
        const safeDescription = String(server.description || "").trim();
        const logo = resolveMediaUrl(server.banner_url || "");
        const descHtml = safeDescription
          ? `<p class="partner-server-desc">${escapeHtml(safeDescription)}</p>`
          : "";
        const card = document.createElement("article");
        card.className = "partner-server-card";
        card.innerHTML = `
          <div class="partner-server-head">
            <div style="display:flex;align-items:center;gap:10px;">
              ${logo ? `<img class="partner-server-logo" src="${escapeHtml(logo)}" alt="Logo de ${safeName}" loading="lazy" data-logo-src="${escapeHtml(logo)}" />` : ""}
              <strong>${safeName}</strong>
            </div>
            <span class="pill">${safeStatus}</span>
          </div>
          <div class="partner-server-meta">
            <span class="pill">Anúncios: ${server.listing_count}</span>
          </div>
          ${safeSite ? `<a class="link-ghost" href="${escapeHtml(safeSite)}" target="_blank" rel="noopener">Site oficial</a>` : ""}
          ${safeDiscord ? `<a class="link-ghost" href="${escapeHtml(safeDiscord)}" target="_blank" rel="noopener">Discord oficial</a>` : ""}
          ${descHtml}
          <p class="helper">Criado em ${formatDateTime(server.created_at)}</p>
          <div class="partner-server-actions">
            <a class="btn btn-ghost" href="${escapeHtml(gameUrl)}">Ver anúncios</a>
            <button class="btn btn-ghost partner-edit-server-btn" type="button" data-server-id="${escapeHtml(server.id)}">Editar</button>
          </div>
        `;
        const cardLogo = card.querySelector(".partner-server-logo");
        if (cardLogo) {
          cardLogo.addEventListener("error", () => {
            if (cardLogo.dataset.fallbackApplied === "1") return;
            cardLogo.dataset.fallbackApplied = "1";
            cardLogo.src = "img/logo.png";
          });
        }
        partnerServerList.appendChild(card);
      });
    }

    async function refreshConnectStatus() {
      try {
        ensureClient();
        connectFeedback.textContent = "Atualizando status do Connect...";
        refreshConnectBtn.disabled = true;
        const { data: sessionData } = await supabase.auth.getSession();
        const token = sessionData.session?.access_token || "";
        const { data, error } = await supabase.functions.invoke("partner_connect_onboarding", {
          body: {
            action: "status",
            userToken: token,
          },
          headers: token
            ? {
                Authorization: `Bearer ${token}`,
                apikey: SUPABASE_ANON_KEY,
              }
            : {},
        });
        if (error || !data?.ok) {
          const errorMessage = await resolveFunctionErrorMessage(error, data, "Erro ao consultar status Connect.");
          throw new Error(errorMessage);
        }
        currentProfile = {
          ...currentProfile,
          is_partner: true,
          stripe_connect_account_id: data.accountId,
          stripe_connect_charges_enabled: data.chargesEnabled,
          stripe_connect_payouts_enabled: data.payoutsEnabled,
          stripe_connect_details_submitted: data.detailsSubmitted,
          stripe_connect_onboarded_at: data.onboarded
            ? (currentProfile?.stripe_connect_onboarded_at || new Date().toISOString())
            : null,
        };
        renderPartnerProfile(currentProfile);
        connectFeedback.textContent = data.onboarded
          ? "Conta Connect pronta para recebimentos."
          : "Conta Connect ainda pendente de conclusão.";
      } catch (err) {
        console.error(err);
        connectFeedback.textContent = err?.message || "Erro ao atualizar status do Connect.";
      } finally {
        refreshConnectBtn.disabled = false;
      }
    }

    async function startOnboarding() {
      try {
        ensureClient();
        connectFeedback.textContent = "Gerando link de onboarding...";
        startConnectBtn.disabled = true;
        const { data: sessionData } = await supabase.auth.getSession();
        const token = sessionData.session?.access_token || "";
        const { data, error } = await supabase.functions.invoke("partner_connect_onboarding", {
          body: {
            action: "onboard",
            returnBaseUrl: window.location.origin,
            userToken: token,
          },
          headers: token
            ? {
                Authorization: `Bearer ${token}`,
                apikey: SUPABASE_ANON_KEY,
              }
            : {},
        });
        if (error || !data?.ok || !data?.onboardingUrl) {
          const errorMessage = await resolveFunctionErrorMessage(error, data, "Erro ao iniciar onboarding.");
          throw new Error(errorMessage);
        }
        window.location.href = data.onboardingUrl;
      } catch (err) {
        console.error(err);
        connectFeedback.textContent = err?.message || "Erro ao iniciar onboarding Connect.";
        startConnectBtn.disabled = false;
      }
    }

    async function init() {
      try {
        ensureClient();
        const { data } = await supabase.auth.getSession();
        currentUser = data.session?.user || null;
        updateAuthUI();
        if (!currentUser) {
          window.location.replace("index.html");
          return;
        }

        const [profile, servers, payoutSummary] = await Promise.all([
          fetchPartnerProfile(),
          fetchOwnedServers(),
          fetchPartnerPayoutSummary(),
        ]);
        const hasPartnerAccess = Boolean(profile?.is_partner || profile?.is_admin || (servers || []).length > 0);
        if (!hasPartnerAccess) {
          window.location.replace("index.html");
          return;
        }
        renderPartnerProfile(profile);
        renderServers(servers);
        renderPartnerPayoutSummary(payoutSummary);

        const params = new URLSearchParams(window.location.search);
        if (params.get("connect") === "return") {
          connectFeedback.textContent = "Retorno do Stripe recebido. Atualize o status para confirmar a ativação.";
        } else if (params.get("connect") === "retry") {
          connectFeedback.textContent = "Onboarding não concluído. Tente novamente.";
        }

        markContentReady();
        revealPage();
      } catch (err) {
        console.error(err);
        connectFeedback.textContent = err?.message || "Erro ao carregar área de parceiros.";
        markContentReady();
        revealPage();
      }
    }

    authBtn?.addEventListener("click", handleAuthClick);
    startConnectBtn?.addEventListener("click", startOnboarding);
    refreshConnectBtn?.addEventListener("click", refreshConnectStatus);
    avatarBtn?.addEventListener("click", (event) => {
      event.stopPropagation();
      userMenu?.classList.toggle("open");
    });
    document.addEventListener("click", (event) => {
      if (!userMenu) return;
      if (!userMenu.contains(event.target)) {
        userMenu.classList.remove("open");
      }
    });
    logoutBtn?.addEventListener("click", async () => {
      try {
        ensureClient();
        await supabase.auth.signOut();
        currentUser = null;
        updateAuthUI();
        window.location.href = "index.html";
      } catch (_err) {
        // ignore
      }
    });

    function goToCreateListing() {
      if (!currentUser) {
        window.location.href = "index.html";
        return;
      }
      window.location.href = "listing-create.html";
    }
    createListingBtn?.addEventListener("click", goToCreateListing);
    menuCreateListing?.addEventListener("click", () => {
      userMenu?.classList.remove("open");
      goToCreateListing();
    });

    partnerServerList?.addEventListener("click", (event) => {
      const button = event.target?.closest?.(".partner-edit-server-btn");
      if (!button) return;
      const serverId = button.getAttribute("data-server-id");
      if (!serverId) return;
      openEditModal(serverId);
    });

    partnerEditClose?.addEventListener("click", closeEditModal);
    partnerEditCancel?.addEventListener("click", closeEditModal);
    partnerEditModal?.addEventListener("click", (event) => {
      if (event.target === partnerEditModal) {
        closeEditModal();
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && partnerEditModal?.classList.contains("open")) {
        closeEditModal();
      }
    });

    partnerEditLogoFile?.addEventListener("change", () => {
      clearLogoPreviewObjectUrl();
      const file = partnerEditLogoFile.files?.[0];
      if (!file) {
        setLogoPreview(currentEditBannerUrl || "");
        return;
      }
      editLogoPreviewObjectUrl = URL.createObjectURL(file);
      setLogoPreview(editLogoPreviewObjectUrl);
    });

    partnerEditLogoPreview?.addEventListener("error", () => {
      if (partnerEditLogoPreview.dataset.fallbackApplied === "1") return;
      partnerEditLogoPreview.dataset.fallbackApplied = "1";
      partnerEditLogoPreview.src = "img/logo.png";
      partnerEditLogoPreview.style.display = "block";
    });

    partnerEditForm?.addEventListener("submit", saveServerSettings);

    init();
  </script>
</body>
</html>
